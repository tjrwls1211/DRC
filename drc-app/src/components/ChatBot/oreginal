import React, { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, ScrollView, StyleSheet, KeyboardAvoidingView, Linking } from 'react-native';
import axios from 'axios';
import { everyday } from '../restless-green-hummus/components/ChatBot_Api';

// 날짜와 키워드를 추출하는 헬퍼 함수
export const extractDateAndKeyword = (input) => {
  // 다양한 날짜 형식을 처리하는 정규식
  const dateRegex = /(\d{2}|\d{4})[년\s]*\.?\s*(\d{1,2})[월\s]*\.?\s*(\d{1,2})[일]?|(\d{2})(\d{2})(\d{2})|(\d{4})(\d{2})(\d{2})|(\d{2})-(\d{2})-(\d{2})|(\d{4})-(\d{2})-(\d{2})/;
  const dateMatch = input.match(dateRegex);

  let date = null;

  // '년', '월', '일'이 포함된 경우
  if (dateMatch && dateMatch[1]) {
    let year = dateMatch[1].length === 2 ? `20${dateMatch[1]}` : dateMatch[1]; // 2자리 연도 처리
    let month = dateMatch[2].padStart(2, '0');
    let day = dateMatch[3].padStart(2, '0');
    date = `${year}-${month}-${day}`;
  }
  // YYMMDD 형식인 경우
  else if (dateMatch && dateMatch[4]) {
    let year = `20${dateMatch[4]}`; // 2자리 연도 처리
    let month = dateMatch[5].padStart(2, '0');
    let day = dateMatch[6].padStart(2, '0');
    date = `${year}-${month}-${day}`;
  }
  // YYYYMMDD 형식인 경우
  else if (dateMatch && dateMatch[7]) {
    let year = dateMatch[7];
    let month = dateMatch[8].padStart(2, '0');
    let day = dateMatch[9].padStart(2, '0');
    date = `${year}-${month}-${day}`;
  }
  // YY-MM-DD 형식인 경우 (24-10-22)
  else if (dateMatch && dateMatch[10]) {
    let year = `20${dateMatch[10]}`; // 2자리 연도 처리
    let month = dateMatch[11].padStart(2, '0');
    let day = dateMatch[12].padStart(2, '0');
    date = `${year}-${month}-${day}`;
  }
  // YYYY-MM-DD 형식인 경우 (2024-10-22)
  else if (dateMatch && dateMatch[13]) {
    let year = dateMatch[13];
    let month = dateMatch[14].padStart(2, '0');
    let day = dateMatch[15].padStart(2, '0');
    date = `${year}-${month}-${day}`;
  }

  const keywords = ["급가속", "급제동", "급발진", "주행정보"];
  const keyword = keywords.find((kw) => input.includes(kw)) || null;

  console.log(date, keyword); // 결과를 콘솔에 출력

  return { date, keyword };
};
{/*extractHelpers*/}



// 기본 챗봇 응답
const chatbotResponses = {
  "급가속": "급가속은 갑작스럽게 가속하는 상황을 말합니다. 이를 방지하기 위해 서서히 가속하는 것이 좋습니다.",
  "급제동": "급제동은 갑작스럽게 브레이크를 밟는 상황입니다. 주의해서 안전하게 운전하세요.",
  "주행정보": "주행 정보는 속도, 연비 등의 데이터를 기반으로 차량 상태를 확인할 수 있습니다.",
  "앱 도움말": "앱에 대한 도움이 필요하면 고객센터에 문의해 주세요.",
  "고객지원": "고객지원과 관련된 정보는 고객센터에서 확인 가능합니다.",
};

const ChatbotScreen = ({ navigation }) => {
  const [messages, setMessages] = useState([{ text: "무엇을 도와드릴까요?", isBot: true }]);
  const [inputText, setInputText] = useState('');
  const [showQueryButtons, setShowQueryButtons] = useState(false);
  const [showBackOnly, setShowBackOnly] = useState(false);
  const [showCountermeasure, setShowCountermeasure] = useState(false);

  // GPT API 호출 함수
  const callGPTApi = async (userInput) => {
    try {
      const response = await axios.post('https://api.openai.com/v1/chat/completions', {
        model: 'gpt-4',
        messages: [{ role: 'user', content: userInput }],
      }, {
        headers: {
          'Authorization': `Bearer sk--IL1X1kP5DR2x3WeneOLvm9-tlltWun2BpaDQ5JDzQT3BlbkFJmxHG2V62kTiTJx0eHRmaiI2pSmBz3UY708hzbfg-wA`, // API 키를 여기에 입력하세요.
          'Content-Type': 'application/json',
        }
      });
      const botResponse = response.data.choices[0].message.content;
      return botResponse;

    } catch (error) {
      console.error("GPT API 호출 중 오류 발생:", error);
      return "죄송합니다, 답변을 불러오는 중에 오류가 발생했습니다.";
    }
  };

    // 자연어 입력 처리
    const handleSend = async () => {
    if (inputText.trim() === '') return;

    const newMessage = { text: inputText, isBot: false };
    setMessages([...messages, newMessage]);

    // 날짜와 키워드 추출
    const { date, keyword } = extractDateAndKeyword(inputText);

    if (date && keyword) {
        // everydata 호출
        console.log(date, keyword)
        try {
        await everyday(date, [keyword]); // 키워드는 배열로 전달
        const botResponse = `서버에 ${date}와 ${keyword}를 전송했습니다.`; // 서버 응답에 대한 메시지
        setMessages(prevMessages => [...prevMessages, { text: botResponse, isBot: true }]);
        } catch (error) {
        console.error('Error sending request:', error);
        const errorMessage = '서버와의 통신에 실패했습니다.';
        setMessages(prevMessages => [...prevMessages, { text: errorMessage, isBot: true }]);
        }
    } else {
        // 각 키워드에 대한 처리
        const keywords = {
        "급가속": [
            "급가속 데이터 조회",
            "급가속 데이터 확인",
            "급가속 조회",
            "급가속",
            "급가속 횟수",
            "최근 급가속",
            "최근 급가속 조회해줘",
            "최근 급가속 데이터 조회해줘",
            "최근 급가속 데이터",
            "급가속 데이터 조회해줘",
            "급가속 데이터 확인해줘",
            "급가속 데이터 찾아줘"
        ],
        "급제동": [
            "급제동 데이터 조회",
            "급제동 데이터 확인",
            "급제동",
            "급제동 데이터 조회해줘",
            "급제동 데이터 찾아줘",
            "급제동 데이터 확인해줘",
            "급제동 조회"
        ],
        "앱 도움말": [
            "앱도움말",
            "앱 도움말",
            "앱 사용법",
            "앱사용법",
            "도움말",
            "사용법",
            "도와줘"
        ],
        "고객지원": [
            "고객지원",
            "고객 지원",
            "문의",
            "문의하기",
            "문의 하기",
            "질문",
            "질문하기",
            "질의하기",
            "질문 하기",
            "질의 하기",
            "질의"
        ],
        "급발진": [
            "급발진 데이터 조회",
            "급발진 데이터 확인",
            "급발진",
            "급발진 데이터 조회해줘",
            "급발진 데이터 찾아줘",
            "급발진 데이터 확인해줘",
            "급발진 조회"
        ],
        "주행정보": [
            "주행정보 데이터 조회",
            "주행정보 데이터 확인",
            "주행정보",
            "주행정보 데이터 조회해줘",
            "주행정보 데이터 찾아줘",
            "주행정보 데이터 확인해줘",
            "주행정보 조회"
        ]
        };

        // 각 키워드에 대한 처리
        for (const [key, phrases] of Object.entries(keywords)) {
        // 입력 텍스트가 특정 키워드와 정확히 일치하는지 확인
        if (phrases.some(phrase => inputText.trim() === phrase)) {
            handleButtonPress(key);
            setInputText(''); // 입력 후 텍스트 초기화
            return; // 이후 GPT API 호출을 생략하고 버튼 클릭 요청 처리
        }
    }

    const botResponse = await callGPTApi(inputText);
    setMessages(prevMessages => [...prevMessages, { text: botResponse, isBot: true }]);
    setInputText(''); // 입력 후 텍스트 초기화
        }
    };

  // 버튼 클릭 처리
  const handleButtonPress = (buttonText) => {
    const botResponse = chatbotResponses[buttonText];
    if (botResponse) {
      setMessages(prevMessages => [...prevMessages, { text: botResponse, isBot: true }]);
    }

    if (buttonText === "급가속" || buttonText === "급제동" || buttonText === "주행정보") {
      setShowQueryButtons(true);
    } else if (buttonText === "급발진") {
      setShowCountermeasure(true);
    } else if (buttonText === "고객지원") {
      handleEmailSupport();
    }
  };

  // 고객지원 이메일 처리
  const handleEmailSupport = () => {
    const email = "btr0809@naver.com";
    const subject = encodeURIComponent("고객 지원 요청");
    const body = encodeURIComponent("안녕하세요,\n\n고객 지원 요청 내용:\n\n");

    const mailtoUrl = `mailto:${email}?subject=${subject}&body=${body}`;
    Linking.openURL(mailtoUrl).catch(err => console.error("Unable to open email client", err));

    setMessages(prevMessages => [...prevMessages, { text: "이메일 클라이언트를 열었습니다. 요청 내용을 작성하세요.", isBot: true }]);
  };

  // 급발진 대처방법 처리
  const handleCountermeasurePress = () => {
    const countermeasureResponse =
      "급발진 대처방법:\n\n" +
      "1. **브레이크 페달을 강하게 밟기**\n" +
      "즉시 브레이크 페달을 최대한 강하게 밟아 차량 속도를 줄이도록 합니다.\n\n" +
      "2. **기어를 중립(N)으로 전환**\n" +
      "브레이크를 밟으면서 변속 레버를 중립(N) 기어로 바꿉니다. 이렇게 하면 엔진의 동력 전달이 차단됩니다.\n\n" +
      "3. **엔진을 끄기 (시동 Off)**\n" +
      "기어를 중립으로 변경한 후, 차량이 완전히 멈추지 않았다면 시동을 끄는 것도 고려할 수 있습니다.\n\n" +
      "4. **비상등을 켜고 차선 변경**\n" +
      "차량을 안전한 곳으로 옮기기 위해 비상등을 켜고, 주변 교통 상황을 확인하여 안전한 위치로 이동합니다.";

    setMessages(prevMessages => [...prevMessages, { text: countermeasureResponse, isBot: true }]);
    setShowCountermeasure(false); // 대처방법 보여준 후 숨김
  };

  // 조회 및 뒤로가기 버튼 처리
  const handleQueryPress = () => {
    setShowBackOnly(true);
    setShowQueryButtons(false);
    setMessages(prevMessages => [...prevMessages, { text: "조회 버튼을 클릭했습니다.", isBot: true }]);
  };

  const handleBackPress = () => {
    setShowBackOnly(false);
    setShowQueryButtons(false);
    setMessages(prevMessages => [...prevMessages, { text: "이전 상태로 돌아갔습니다.", isBot: true }]);
  };

  return (
    <KeyboardAvoidingView style={styles.container} behavior="padding">
      <ScrollView contentContainerStyle={styles.chatContainer}>
        {messages.map((message, index) => (
          <View key={index} style={[styles.messageContainer, message.isBot ? styles.botMessage : styles.userMessage]}>
            <Text style={styles.messageText}>{message.text}</Text>
          </View>
        ))}

        {showQueryButtons ? (
          <View style={styles.queryButtonsContainer}>
            <TouchableOpacity style={styles.queryButton} onPress={handleQueryPress}>
              <Text style={styles.queryButtonText}>조회</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.queryButton} onPress={handleBackPress}>
              <Text style={styles.queryButtonText}>뒤로가기</Text>
            </TouchableOpacity>
          </View>
        ) : showBackOnly ? (
          <View style={styles.queryButtonsContainer}>
            <TouchableOpacity style={styles.queryButton} onPress={handleCountermeasurePress}>
              <Text style={styles.queryButtonText}>대처방법</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.queryButton} onPress={handleBackPress}>
              <Text style={styles.queryButtonText}>뒤로가기</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <View style={styles.buttonsContainer}>
            <View style={styles.row}>
              <TouchableOpacity style={styles.button} onPress={() => handleButtonPress("급가속")}>
                <Text style={styles.buttonText}>급가속</Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.button} onPress={() => handleButtonPress("급제동")}>
                <Text style={styles.buttonText}>급제동</Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.button} onPress={() => handleButtonPress("급발진")}>
                <Text style={styles.buttonText}>급발진</Text>
              </TouchableOpacity>
            </View>
            <View style={styles.row}>
              <TouchableOpacity style={styles.button} onPress={() => handleButtonPress("주행정보")}>
                <Text style={styles.buttonText}>주행정보</Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.button} onPress={() => handleButtonPress("앱 도움말")}>
                <Text style={styles.buttonText}>앱 도움말</Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.button} onPress={() => handleButtonPress("고객지원")}>
                <Text style={styles.buttonText}>고객지원</Text>
              </TouchableOpacity>
            </View>
          </View>
        )}
      </ScrollView>

      <View style={styles.inputContainer}>
        <TextInput
          style={styles.input}
          placeholder="메시지를 입력하세요..."
          value={inputText}
          onChangeText={setInputText}
          onSubmitEditing={handleSend}
          returnKeyType="send"
        />
        <TouchableOpacity style={styles.sendButton} onPress={handleSend}>
          <Text style={styles.sendButtonText}>전송</Text>
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
};


const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f4f4f4',
  },
  chatContainer: {
    paddingVertical: 20,
    paddingHorizontal: 10,
  },
  messageContainer: {
    marginBottom: 10,
    padding: 10,
    borderRadius: 10,
  },
  botMessage: {
    alignSelf: 'flex-start',
    backgroundColor: '#e1f5fe',
  },
  userMessage: {
    alignSelf: 'flex-end',
    backgroundColor: '#c8e6c9',
  },
  messageText: {
    fontSize: 16,
  },
  buttonsContainer: {
    marginTop: 20,
  },
  row: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginBottom: 10,
  },
  button: {
    padding: 10,
    backgroundColor: '#81d4fa',
    borderRadius: 5,
  },
  buttonText: {
    fontSize: 16,
    color: '#fff',
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 10,
    backgroundColor: '#fff',
  },
  input: {
    flex: 1,
    borderColor: '#ccc',
    borderWidth: 1,
    borderRadius: 5,
    paddingHorizontal: 10,
  },
  sendButton: {
    backgroundColor: '#81d4fa',
    borderRadius: 5,
    padding: 10,
    marginLeft: 10,
  },
  sendButtonText: {
    color: '#fff',
    fontSize: 16,
  },
  queryButtonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 10,
  },
  queryButton: {
    padding: 10,
    backgroundColor: '#4caf50',
    borderRadius: 5,
  },
  queryButtonText: {
    color: '#fff',
    fontSize: 16,
  },
});

export default ChatbotScreen;

